# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JG0du80vnn9PyXYVeJ0G1GT8u_rNZSZc
"""

import tensorflow as tf
from tensorflow.keras.datasets import mnist

# The data is already split into training and testing sets for us
(X_train, y_train), (X_test, y_test) = mnist.load_data()

print(X_train.shape)

# Check the original shape of the data
print("Original X_train shape:", X_train.shape)

# Normalize the data
X_train = X_train.astype('float32') / 255.0
X_test = X_test.astype('float32') / 255.0

# Reshape the data to add a color channel
X_train = X_train.reshape(-1, 28, 28, 1)
X_test = X_test.reshape(-1, 28, 28, 1)

# Check the new shape
print("Reshaped and normalized X_train shape:", X_train.shape)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense

# Create a new, empty model
model = Sequential()

# Add the Convolutional and Max-Pooling layers
model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(28, 28, 1)))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Flatten the output from the previous layers
model.add(Flatten())

# Add the Dense layers for classification
model.add(Dense(128, activation='relu'))
model.add(Dense(10, activation='softmax'))

# Print a summary of the model's structure
model.summary()

# Compile the model
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Train the model on our training data
history = model.fit(X_train, y_train, epochs=5, validation_data=(X_test, y_test))

import matplotlib.pyplot as plt
import numpy as np

# Select a single image from our test set
test_image = X_test[0]
true_label = y_test[0]

# Add an extra dimension to the image so the model can process it
test_image_for_model = np.expand_dims(test_image, axis=0)

# Make a prediction
predictions = model.predict(test_image_for_model)
predicted_label = np.argmax(predictions)

# Display the image and the prediction
print(f"The model predicted: {predicted_label}")
print(f"The actual label is: {true_label}")
plt.imshow(test_image.reshape(28, 28), cmap=plt.cm.binary)
plt.title(f"Predicted: {predicted_label}, Actual: {true_label}")
plt.show()

